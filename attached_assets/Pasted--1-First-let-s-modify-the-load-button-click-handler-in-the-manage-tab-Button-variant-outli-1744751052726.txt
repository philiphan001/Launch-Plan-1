// 1. First, let's modify the load button click handler in the manage tab:
<Button 
  variant="outline" 
  size="sm" 
  onClick={() => {
    // Instead of directly setting state, navigate to the same page with the projection ID
    const url = `/projections?id=${projection.id}&t=${Date.now()}`;
    window.location.href = url;
  }}
>
  Load
</Button>

// 2. Let's improve the projection loading logic in the component:
useEffect(() => {
  // Reset all state when projectionId changes
  if (projectionId) {
    // Clear existing data
    setProjectionData(null);
    setProjectionName('');
    setTimeframe("10 Years");
    setAge(25);
    setStartingSavings(5000);
    setIncome(40000);
    setExpenses(35000);
    setIncomeGrowth(3.0);
    setStudentLoanDebt(0);
    setEmergencyFundAmount(10000);
    setPersonalLoanTermYears(5);
    setPersonalLoanInterestRate(8.0);
    
    // Force a refetch of the projection data
    refetchProjection();
  }
}, [projectionId, refetchProjection]);

// 3. Let's modify the saved projection query to be more aggressive with refetching:
const { data: savedProjection, isLoading: isLoadingSavedProjection, error: savedProjectionError, refetch: refetchProjection } = useQuery({
  queryKey: ['/api/financial-projections/detail', projectionId],
  queryFn: async () => {
    if (!projectionId) {
      console.log("No projection ID provided, skipping fetch");
      return null;
    }
    
    try {
      const response = await fetch(`/api/financial-projections/detail/${projectionId}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch projection: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error fetching projection:", error);
      throw error;
    }
  },
  enabled: !!projectionId,
  retry: false,
  staleTime: 0,
  gcTime: 0,
  refetchOnMount: true,
  refetchOnWindowFocus: true,
  // Add these new options
  refetchOnReconnect: true,
  refetchInterval: false,
  suspense: false
});

// 4. Let's add a loading state to prevent rendering before data is ready:
const [isLoadingProjection, setIsLoadingProjection] = useState(false);

// 5. Modify the view TabsContent to handle loading states:
<TabsContent value="view">
  <div className="p-6">
    {isLoadingProjection || isLoadingSavedProjection ? (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    ) : !projectionData ? (
      <div className="text-center text-gray-500">
        No projection data available
      </div>
    ) : (
      // Your existing view content
    )}
  </div>
</TabsContent>